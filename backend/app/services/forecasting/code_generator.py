"""
Code generation service - adapted from arauto/lib/generate_code.py
"""
import numpy as np
from typing import List, Optional


class CodeGenerator:
    """Service for generating Python code"""
    
    @staticmethod
    def generate_code(
        filename: str,
        ds_column: str,
        y: str,
        test_stationarity_code: str,
        test_set_size: int,
        seasonality: int,
        p: int,
        d: int,
        q: int,
        P: int,
        D: int,
        Q: int,
        s: int,
        exog_variables_names: Optional[List[str]] = None,
        transformation_function_name: str = "lambda x: x",
        periods_to_forecast: int = 12,
        data_frequency: str = "Monthly"
    ) -> str:
        """
        Generate complete Python code for the analysis
        
        Adapted from arauto/lib/generate_code.py
        """
        exog_vars_str = (
            f"df[{exog_variables_names}]" if exog_variables_names else "None"
        )
        
        code = f'''# Time Series Forecasting Code
# Generated by TimeLab

import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import statsmodels.api as sm

from math import sqrt
from sklearn.metrics import mean_squared_error, mean_absolute_error
from statsmodels.tsa.seasonal import seasonal_decompose
from statsmodels.tsa.stattools import adfuller

# Configure pandas display
pd.set_option('display.float_format', lambda x: '%.3f' % x)

# Helper function: MAPE
def mean_abs_pct_error(actual_values, forecast_values):
    """Calculate Mean Absolute Percentage Error"""
    err = 0
    for i in range(len(forecast_values)):
        if actual_values.iloc[i] != 0:
            err += np.abs(actual_values.iloc[i] - forecast_values.iloc[i]) / abs(actual_values.iloc[i])
    return err * 100 / len(forecast_values)

# Load dataset
df = pd.read_csv('{filename}')

# Set date column as index
df.set_index('{ds_column}', inplace=True)
df.index = pd.to_datetime(df.index)

# Extract target variable
df = df['{y}']

# Stationarity testing
{test_stationarity_code}

# Prepare data
train_transformation_func = {transformation_function_name}
train_set = train_transformation_func(df.iloc[:-{test_set_size}])
test_set = train_transformation_func(df.iloc[-{test_set_size}:])

# Exogenous variables
exogenous_variables = {exog_vars_str}

# Train model
mod = sm.tsa.statespace.SARIMAX(
    train_set,
    order=({p}, {d}, {q}),
    exog=exogenous_variables.iloc[:-{test_set_size}] if exogenous_variables is not None else None,
    seasonal_order=({P}, {D}, {Q}, {s}),
    enforce_invertibility=False
)

try:
    results = mod.fit()
except np.linalg.LinAlgError:
    mod = sm.tsa.statespace.SARIMAX(
        train_set,
        order=({p}, {d}, {q}),
        exog=exogenous_variables.iloc[:-{test_set_size}] if exogenous_variables is not None else None,
        seasonal_order=({P}, {D}, {Q}, {s}),
        enforce_invertibility=False,
        initialization='approximate_diffuse'
    )
    results = mod.fit()

print(results.summary())

# Generate forecasts
forecasts = results.forecast({periods_to_forecast})
confidence_interval = results.get_forecast({periods_to_forecast}).conf_int()

print("\\nForecasts:")
print(forecasts)
print("\\nConfidence Intervals:")
print(confidence_interval)
'''
        
        return code

